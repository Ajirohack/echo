#!/usr/bin/env node

/**
 * Migration Script: Move Hardcoded Values to Environment Variables
 * 
 * This script helps migrate hardcoded configuration values to environment variables.
 * It scans configuration files, identifies hardcoded values, and generates a .env file
 * with appropriate entries.
 */

const fs = require('fs');
const path = require('path');
const readline = require('readline');

// Directories
const ROOT_DIR = path.resolve(__dirname, '..');
const CONFIG_DIR = path.join(ROOT_DIR, 'config');
const ENV_EXAMPLE_PATH = path.join(ROOT_DIR, '.env.example');
const ENV_PATH = path.join(ROOT_DIR, '.env');

// Configuration files to scan
const CONFIG_FILES = [
  'translation-config.json',
  'tts-config.json',
  'ai-providers.json',
  'deepl-config.json',
  'gpt4o-config.json',
  'google-translate-config.json',
  'azure-translator-config.json'
];

// Mapping of config paths to environment variable names
const CONFIG_TO_ENV_MAPPING = {
  // Translation config
  'services.deepl.apiKey': 'DEEPL_API_KEY',
  'services.google.apiKey': 'GOOGLE_TRANSLATE_API_KEY',
  'services.azure.apiKey': 'AZURE_TRANSLATOR_API_KEY',
  'services.gpt4o.apiKey': 'OPENAI_API_KEY',
  'services.azure.region': 'AZURE_REGION',

  // TTS config
  'services.elevenlabs.apiKey': 'ELEVENLABS_API_KEY',
  'services.azure.apiKey': 'AZURE_TTS_API_KEY',

  // AI providers
  'providers.openai.apiKey': 'OPENAI_API_KEY',
  'providers.groq.apiKey': 'GROQ_API_KEY',
  'providers.huggingface.apiKey': 'HUGGINGFACE_API_KEY',

  // Individual service configs
  'apiKey': null, // Will be determined based on file name
  'region': 'AZURE_REGION'
};

// Create readline interface
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});

/**
 * Get nested object value by dot notation path
 */
function getNestedValue(obj, path) {
  return path.split('.').reduce((current, key) => current && current[key], obj);
}

/**
 * Check if a value appears to be a placeholder or example
 */
function isPlaceholderValue(value) {
  if (typeof value !== 'string') return false;

  const lowerValue = value.toLowerCase();
  return (
    lowerValue.includes('your_') ||
    lowerValue.includes('api_key') ||
    lowerValue.includes('example') ||
    lowerValue.includes('placeholder') ||
    lowerValue === '' ||
    lowerValue === 'your-api-key-here' ||
    lowerValue.startsWith('sk-') && lowerValue.length < 10 // Short OpenAI-like key
  );
}

/**
 * Extract environment variables from config files
 */
async function extractEnvVars() {
  const envVars = {};

  for (const configFile of CONFIG_FILES) {
    const configPath = path.join(CONFIG_DIR, configFile);

    if (!fs.existsSync(configPath)) {
      console.log(`Config file not found: ${configFile}, skipping...`);
      continue;
    }

    try {
      const config = JSON.parse(fs.readFileSync(configPath, 'utf8'));
      const fileBaseName = path.basename(configFile, '.json');

      // Determine which service this config is for
      let serviceType = '';
      if (fileBaseName.includes('deepl')) serviceType = 'DEEPL';
      else if (fileBaseName.includes('google')) serviceType = 'GOOGLE_TRANSLATE';
      else if (fileBaseName.includes('azure')) serviceType = 'AZURE_TRANSLATOR';
      else if (fileBaseName.includes('gpt') || fileBaseName.includes('openai')) serviceType = 'OPENAI';

      // Extract values based on mapping
      for (const [configPath, envVarName] of Object.entries(CONFIG_TO_ENV_MAPPING)) {
        let value = getNestedValue(config, configPath);

        // Skip if value doesn't exist or is a placeholder
        if (value === undefined || isPlaceholderValue(value)) continue;

        // Determine environment variable name for 'apiKey' based on file
        let actualEnvVarName = envVarName;
        if (configPath === 'apiKey' && serviceType) {
          actualEnvVarName = `${serviceType}_API_KEY`;
        }

        if (actualEnvVarName && value) {
          envVars[actualEnvVarName] = value;
        }
      }
    } catch (error) {
      console.error(`Error processing ${configFile}:`, error.message);
    }
  }

  return envVars;
}

/**
 * Generate .env file content
 */
function generateEnvFileContent(envVars) {
  let content = '';

  // Add header
  content += '# Environment Variables for Echo Translation App\n';
  content += '# Generated by migration script\n\n';

  // Add API keys section
  content += '# API Keys\n';
  for (const [key, value] of Object.entries(envVars)) {
    if (key.includes('API_KEY') || key.includes('KEY')) {
      content += `${key}=${value}\n`;
    }
  }

  content += '\n# Service Configuration\n';
  for (const [key, value] of Object.entries(envVars)) {
    if (!key.includes('API_KEY') && !key.includes('KEY')) {
      content += `${key}=${value}\n`;
    }
  }

  // Add additional configuration options from .env.example
  if (fs.existsSync(ENV_EXAMPLE_PATH)) {
    const exampleContent = fs.readFileSync(ENV_EXAMPLE_PATH, 'utf8');
    const exampleLines = exampleContent.split('\n');

    content += '\n# Additional Configuration Options\n';
    content += '# Uncomment and set values as needed\n';

    for (const line of exampleLines) {
      // Skip empty lines, comments, and variables we've already set
      if (!line.trim() || line.startsWith('#')) {
        continue;
      }

      const match = line.match(/^([A-Z_]+)=/i);
      if (match && match[1] && !envVars[match[1]]) {
        content += `# ${line}\n`;
      }
    }
  }

  return content;
}

/**
 * Main function
 */
async function main() {
  console.log('Migration Script: Move Hardcoded Values to Environment Variables\n');

  try {
    // Extract environment variables from config files
    console.log('Scanning configuration files for hardcoded values...');
    const envVars = await extractEnvVars();

    if (Object.keys(envVars).length === 0) {
      console.log('No hardcoded values found in configuration files.');
      rl.close();
      return;
    }

    console.log(`Found ${Object.keys(envVars).length} environment variables to migrate.`);

    // Generate .env file content
    const envContent = generateEnvFileContent(envVars);

    // Check if .env file already exists
    if (fs.existsSync(ENV_PATH)) {
      rl.question('.env file already exists. Overwrite? (y/N): ', (answer) => {
        if (answer.toLowerCase() === 'y') {
          fs.writeFileSync(ENV_PATH, envContent, 'utf8');
          console.log(`Environment variables written to ${ENV_PATH}`);
        } else {
          const backupPath = `${ENV_PATH}.new`;
          fs.writeFileSync(backupPath, envContent, 'utf8');
          console.log(`Environment variables written to ${backupPath}`);
        }

        console.log('\nNext steps:');
        console.log('1. Review the .env file and make any necessary adjustments');
        console.log('2. Run the setup-config.js script to update configuration files');
        console.log('3. Test the application to ensure it works with environment variables');

        rl.close();
      });
    } else {
      fs.writeFileSync(ENV_PATH, envContent, 'utf8');
      console.log(`Environment variables written to ${ENV_PATH}`);

      console.log('\nNext steps:');
      console.log('1. Review the .env file and make any necessary adjustments');
      console.log('2. Run the setup-config.js script to update configuration files');
      console.log('3. Test the application to ensure it works with environment variables');

      rl.close();
    }
  } catch (error) {
    console.error('Error during migration:', error);
    rl.close();
  }
}

// Run the script
main();